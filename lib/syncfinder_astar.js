// Generated by CoffeeScript 1.6.2
(function() {
  var Heap, SQRT2, backtrace, endLoc, grid, heuristic, locToClosed, locToF, locToG, locToH, locToOpen, locToParent, openList, startLoc, syncfinder_astar;

  Heap = require("./heap");

  openList = new Heap();

  startLoc = 0;

  endLoc = 0;

  grid = null;

  locToClosed = null;

  locToOpen = null;

  locToG = null;

  locToH = null;

  locToF = null;

  locToParent = null;

  SQRT2 = Math.SQRT2;

  heuristic = function(dx, dy) {
    return dx + dy;
  };

  backtrace = function(node) {
    var path;

    path = [];
    path.push(node);
    while (locToParent[node]) {
      node = locToParent[node];
      path.unshift(node);
    }
    return path;
  };

  syncfinder_astar = {
    findPath: function(startX, startY, endX, endY, theGrid) {
      var i, neighbor, neighborNode, neighbors, ng, node, nodeX, nodeY, x, y, _i, _ref;

      startLoc = startX << 16 | startY;
      endLoc = endX << 16 | endY;
      grid = theGrid;
      locToClosed = {};
      locToOpen = {};
      locToG = {};
      locToF = {};
      locToH = {};
      locToParent = {};
      locToG[startLoc] = 0;
      locToF[startLoc] = 0;
      openList.reset(locToF);
      openList.push(startLoc);
      locToOpen[startLoc] = true;
      while (openList.isNotEmpty()) {
        node = openList.pop();
        locToClosed[node] = true;
        if (node === endLoc) {
          return backtrace(node);
        }
        nodeX = node >>> 16;
        nodeY = node & 0xffff;
        neighbors = grid.getNeighbors(nodeX, nodeY);
        for (i = _i = 0, _ref = neighbors.length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          neighbor = neighbors[i];
          if (locToClosed[neighbor]) {
            continue;
          }
          x = neighbor >>> 16;
          y = neighbor & 0xffff;
          ng = locToG[node] + (x === nodeX || y === nodeY ? 1 : SQRT2);
          if (!locToOpen[neighbor] || ng < locToG[neighbor]) {
            locToG[neighbor] = ng;
            locToH[neighbor] = locToH[neighbor] || heuristic(Math.abs(x - endX), Math.abs(y - endY));
            locToF[neighbor] = locToG[neighbor] + locToH[neighbor];
            neighborNode = x << 16 | y;
            locToParent[neighborNode] = node;
            if (!locToOpen[neighbor]) {
              openList.push(neighborNode);
              locToOpen[neighbor] = true;
            } else {
              openList.updateItem(neighborNode);
            }
          }
        }
      }
      return null;
    }
  };

  module.exports = syncfinder_astar;

}).call(this);
